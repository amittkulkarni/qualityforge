"""Configuration settings for Quality Forge."""

import os
from pathlib import Path
from typing import Optional, Dict, Any

from pydantic import BaseSettings, Field, validator
from pydantic_settings import BaseSettings as Settings


class QualityForgeSettings(Settings):
    """Quality Forge configuration settings."""
    
    # API Configuration
    groq_api_key: str = Field(..., env="GROQ_API_KEY")
    github_token: Optional[str] = Field(None, env="GITHUB_TOKEN")
    
    # Model Configuration
    groq_model: str = Field("groq/llama-3.1-8b-instant", env="GROQ_MODEL")
    max_tokens: int = Field(12000, env="MAX_TOKENS")
    temperature: float = Field(0.1, env="TEMPERATURE")
    
    # Rate Limiting
    rate_limit_per_minute: int = Field(10, env="RATE_LIMIT_PER_MINUTE")
    max_retries: int = Field(3, env="MAX_RETRIES")
    retry_delay: float = Field(1.0, env="RETRY_DELAY")
    
    # File Processing
    max_files: int = Field(10, env="MAX_FILES")
    max_file_size: int = Field(100000, env="MAX_FILE_SIZE")  # 100KB
    
    # Git Configuration
    git_branch_prefix: str = Field("qualityforge", env="GIT_BRANCH_PREFIX")
    git_commit_message: str = Field(
        "feat: Quality Forge automated refactoring",
        env="GIT_COMMIT_MESSAGE"
    )
    
    # PR Configuration
    pr_title_template: str = Field(
        "ðŸ¤– Quality Forge: Automated Code Quality Improvements",
        env="PR_TITLE_TEMPLATE"
    )
    pr_body_template: str = Field(
        """## ðŸ¤– Quality Forge Automated Refactoring

This pull request contains automated code quality improvements generated by Quality Forge.

### Changes Made:
{changes_summary}

### Files Modified:
{files_modified}

### Quality Metrics:
{quality_metrics}

---
*This PR was automatically generated by Quality Forge. Please review carefully before merging.*
""",
        env="PR_BODY_TEMPLATE"
    )
    
    # Vector Database Configuration
    vector_db_path: str = Field("knowledge/vector_store", env="VECTOR_DB_PATH")
    vector_db_collection: str = Field("code_patches", env="VECTOR_DB_COLLECTION")
    
    # Logging
    log_level: str = Field("INFO", env="LOG_LEVEL")
    log_file: Optional[str] = Field(None, env="LOG_FILE")
    
    # Development Settings
    debug: bool = Field(False, env="DEBUG")
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"
        case_sensitive = False
        
    @validator("groq_api_key")
    def validate_groq_api_key(cls, v: str) -> str:
        """Validate that the Groq API key is provided."""
        if not v:
            raise ValueError("GROQ_API_KEY must be provided")
        return v
    
    @validator("max_tokens")
    def validate_max_tokens(cls, v: int) -> int:
        """Validate max tokens is within reasonable limits."""
        if v < 1000 or v > 128000:
            raise ValueError("max_tokens must be between 1000 and 128000")
        return v
    
    @validator("temperature")
    def validate_temperature(cls, v: float) -> float:
        """Validate temperature is within valid range."""
        if v < 0.0 or v > 2.0:
            raise ValueError("temperature must be between 0.0 and 2.0")
        return v
    
    @validator("rate_limit_per_minute")
    def validate_rate_limit(cls, v: int) -> int:
        """Validate rate limit is reasonable."""
        if v < 1 or v > 1000:
            raise ValueError("rate_limit_per_minute must be between 1 and 1000")
        return v
    
    @validator("max_files")
    def validate_max_files(cls, v: int) -> int:
        """Validate max files is within reasonable limits."""
        if v < 1 or v > 50:
            raise ValueError("max_files must be between 1 and 50")
        return v
    
    @validator("max_file_size")
    def validate_max_file_size(cls, v: int) -> int:
        """Validate max file size is reasonable."""
        if v < 1000 or v > 1000000:  # 1KB to 1MB
            raise ValueError("max_file_size must be between 1000 and 1000000 bytes")
        return v
    
    @validator("log_level")
    def validate_log_level(cls, v: str) -> str:
        """Validate log level is valid."""
        valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if v.upper() not in valid_levels:
            raise ValueError(f"log_level must be one of {valid_levels}")
        return v.upper()
    
    def get_vector_db_path(self) -> Path:
        """Get the full path to the vector database."""
        return Path(self.vector_db_path).resolve()
    
    def get_branch_name(self) -> str:
        """Generate a unique branch name for the current run."""
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
        return f"{self.git_branch_prefix}/{timestamp}"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert settings to dictionary (excluding sensitive data)."""
        data = self.dict()
        # Remove sensitive information
        data.pop("groq_api_key", None)
        data.pop("github_token", None)
        return data


# Global settings instance
settings = QualityForgeSettings()